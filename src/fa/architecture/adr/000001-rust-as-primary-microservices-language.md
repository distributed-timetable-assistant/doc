# 000001. انتخاب Rust به‌عنوان زبان اصلی میکروسرویس‌ها

تاریخ: 2025-12-19

## وضعیت

پذیرفته‌شده (با محدودیت‌ها و معیارهای خروج مشخص)

## زمینه (Context)

DiTA یک پلتفرم توزیع‌شده و محاسبات‌محور است که ارزش اصلی آن از کیفیت solverها، مقیاس‌پذیری و اجرای مقرون‌به‌صرفه‌ی بارهای زمان‌بندی به‌دست می‌آید. این سیستم شامل میکروسرویس‌هایی با ماهیت‌های متفاوت است، از جمله:

- سرویس‌های solver با بار پردازشی بالا و موازی‌سازی شدید
- سرویس‌های هماهنگ‌سازی و orchestration
- سرویس‌های کنترلی با تمرکز بر I/O

انتخاب زبان پیاده‌سازی اصلی، یک **تعهد معماری بلندمدت** است که به‌صورت مستقیم بر موارد زیر اثر می‌گذارد:
- هزینه‌ی زیرساخت
- سرعت توسعه
- پایداری و قابلیت اطمینان سیستم
- استخدام و onboarding نیرو
- امکان بازنگری تصمیمات معماری در آینده

بنابراین این تصمیم باید بر پایه‌ی **تحلیل هزینه–فایده** اتخاذ شود، نه صرفاً ترجیح فنی یا اعتقادی.

## تصمیم

Rust به‌عنوان **زبان پیش‌فرض (Primary)** برای میکروسرویس‌های DiTA انتخاب می‌شود، اما **در چارچوب محدودیت‌ها و قیود مشخص** و با پذیرش صریح هزینه‌ها و ریسک‌های آن.

استفاده از Rust **الزامی است** برای:
- سرویس‌های محاسبات‌محور (solverها، evaluatorها، optimizerها)
- سرویس‌های حساس به latency یا دارای throughput بالا
- سرویس‌هایی که ایمنی حافظه، قطعیت رفتاری و عملکرد قابل‌پیش‌بینی مستقیماً بر هزینه یا صحت سیستم اثر دارند

استفاده از Rust **الزامی نیست** برای:
- سرویس‌های تحقیقاتی، آزمایشی یا prototyping سریع
- اجزای سنگین ML یا محاسبات عددی که بلوغ اکوسیستم تعیین‌کننده است
- سرویس‌های glue یا orchestration که سرعت توسعه نسبت به کارایی اولویت دارد

سرویس‌های غیر-Rust باید پشت مرزهای شبکه‌ای شفاف (HTTP / gRPC) ایزوله شده و به‌عنوان اجزای قابل‌جایگزینی در نظر گرفته شوند.

## توجیه تصمیم (Rationale)

### چرا Rust

Rust مزایای **اقتصادی و معماری** زیر را برای بارهای کاری هسته‌ای DiTA فراهم می‌کند:

- تضمین ایمنی حافظه بدون GC و کاهش ریسک‌های production در سرویس‌های long-running
- ویژگی‌های عملکردی قابل‌پیش‌بینی، مناسب برای solverهای CPU-bound
- سربار اجرایی پایین که به افزایش تراکم سرویس‌ها روی نودها و کاهش هزینه زیرساخت منجر می‌شود
- مدل صریح مالکیت داده و هم‌زمانی که با محاسبات موازی و توزیع‌شده هم‌راستا است

این مزایا مستقیماً با اهداف بلندمدت DiTA در زمینه‌ی مقیاس‌پذیری، بهینه‌سازی هزینه و صحت محاسبات هم‌خوانی دارند.

### هزینه‌ها و ریسک‌های پذیرفته‌شده

این تصمیم به‌صورت شفاف **هزینه‌ها و ریسک‌های Rust** را می‌پذیرد:

- منحنی یادگیری و onboarding بالاتر نسبت به زبان‌های رایج بک‌اند
- کاهش سرعت iteration در مراحل ابتدایی کشف محصول
- ریسک قفل‌شدن زودهنگام روی abstractionهای نامناسب به‌دلیل type system قوی
- ضعف نسبی اکوسیستم در حوزه‌ی ML و محاسبات عددی پیشرفته نسبت به Python یا C++

Rust می‌تواند طراحی خوب را تقویت کند، اما در عین حال **طراحی بد را نیز زودتر سخت و تثبیت کند**. این ریسک انکار نمی‌شود و از طریق کنترل دامنه و انضباط معماری مدیریت می‌شود.

## گزینه‌های بررسی‌شده (Alternatives Considered)

### Go
- مزایا: onboarding سریع، اکوسیستم قوی برای سیستم‌های توزیع‌شده، هزینه عملیاتی پایین
- معایب: سربار GC، تضمین‌های ضعیف‌تر در ایمنی حافظه و هم‌زمانی
- دلیل عدم انتخاب به‌عنوان زبان پیش‌فرض: عدم تناسب با بارهای solver محور و محاسباتی سنگین

### Python
- مزایا: اکوسیستم بسیار قوی برای ML و بهینه‌سازی، سرعت بالای prototyping
- معایب: عملکرد ضعیف در runtime و هزینه عملیاتی بالا در مقیاس
- وضعیت: پذیرفته‌شده به‌عنوان زبان ثانویه برای تحقیق و آزمایش

### C++
- مزایا: حداکثر عملکرد و کتابخانه‌های عددی بالغ
- معایب: هزینه نگهداری بالا، ریسک‌های ایمنی حافظه، مقیاس‌پذیری پایین تیم
- دلیل عدم انتخاب: ریسک بلندمدت در پایداری و عملیات

## کنترل دامنه و مرزبندی (Scope Control and Boundaries)

برای جلوگیری از overreach، قیود زیر اعمال می‌شوند:

- شروع استفاده از Rust محدود به سرویس‌های solver و performance-critical است
- سرویس‌های کنترلی و orchestration می‌توانند در صورت توجیه فنی از زبان‌های دیگر استفاده کنند
- تمام ارتباطات بین سرویس‌ها باید از طریق پروتکل‌های شبکه‌ای مشخص انجام شود
- coupling درون‌پردازه‌ای بین زبان‌ها مجاز نیست

## معیارهای خروج و بازنگری (Exit Criteria and Re-evaluation)

این تصمیم **غیرقابل‌بازگشت فرض نمی‌شود**.

انتخاب Rust در صورت وقوع هر یک از شرایط زیر باید بازنگری شود:

- سرعت توسعه به مانعی برای رسیدن به product–market fit تبدیل شود
- هزینه استخدام یا onboarding از آستانه قابل‌قبول عبور کند
- بخش عمده‌ای از سرویس‌ها I/O-bound باشند و سود عملکردی ملموسی از Rust حاصل نشود
- پیچیدگی عملیاتی بیش از صرفه‌جویی زیرساختی باشد

گسترش استفاده از Rust به دسته‌های جدید سرویس تنها پس از بازبینی رسمی مجاز است.

## پیامدها (Consequences)

### پیامدهای مثبت
- کاهش ریسک‌های runtime و افزایش پایداری در سرویس‌های solver
- کاهش هزینه زیرساخت برای بارهای CPU-bound
- هم‌راستایی قوی بین مفاهیم زبان و نیازهای محاسبات موازی

### پیامدهای منفی
- هزینه بالاتر توسعه و onboarding در ابتدای مسیر
- افزایش سختی تغییرات معماری در صورت طراحی مرزهای ضعیف
- نیاز به انضباط بالا برای جلوگیری از over-engineering زودهنگام

---

این ADR بیانگر یک **تصمیم محدودشده و مبتنی بر منطق اقتصادی** است، نه تأیید مطلق Rust برای تمام اجزای سیستم.
